<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UMBRA</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Text:ital,wght@0,400;1,400&display=swap");
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        overflow: hidden;
        font-family: "Cinzel", serif;
      }
      #ui {
        position: relative;
        width: 800px;
        max-width: 100vw;
      }
      canvas {
        display: block;
        width: 100%;
        image-rendering: pixelated;
        cursor: none;
      }
      #overlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.92);
        z-index: 10;
        gap: 16px;
      }
      #overlay h1 {
        font-size: clamp(3rem, 10vw, 5.5rem);
        font-weight: 900;
        letter-spacing: 0.3em;
        color: #f5e6c8;
        text-shadow: 0 0 40px #e8b96080, 0 0 80px #e8b96030;
        animation: flicker 4s ease-in-out infinite;
      }
      @keyframes flicker {
        0%,
        100% {
          opacity: 1;
        }
        92% {
          opacity: 1;
        }
        93% {
          opacity: 0.7;
        }
        94% {
          opacity: 1;
        }
        96% {
          opacity: 0.85;
        }
        97% {
          opacity: 1;
        }
      }
      .tagline {
        font-family: "Crimson Text", serif;
        font-style: italic;
        color: #9a8060;
        font-size: 1rem;
        letter-spacing: 0.1em;
      }
      .hint-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px 28px;
        margin-top: 10px;
      }
      .hint {
        display: flex;
        align-items: center;
        gap: 10px;
        color: #7a6850;
        font-family: "Crimson Text", serif;
        font-size: 0.85rem;
      }
      .key {
        border: 1px solid #5a4830;
        border-radius: 4px;
        padding: 3px 9px;
        color: #f5e6c8;
        font-family: "Cinzel", serif;
        font-size: 0.65rem;
        background: #1a1208;
        white-space: nowrap;
        flex-shrink: 0;
      }
      .start-btn {
        margin-top: 14px;
        background: transparent;
        border: 1px solid #8a6830;
        color: #f5e6c8;
        font-family: "Cinzel", serif;
        font-size: 0.85rem;
        letter-spacing: 0.3em;
        padding: 12px 36px;
        cursor: pointer;
        transition: all 0.25s;
        text-transform: uppercase;
      }
      .start-btn:hover {
        background: #2a1e0a;
        border-color: #e8b960;
        box-shadow: 0 0 20px #e8b96040;
        color: #e8b960;
      }
      #hud {
        position: absolute;
        top: 10px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        padding: 0 16px;
        pointer-events: none;
        z-index: 5;
      }
      #hud-level {
        font-family: "Cinzel", serif;
        font-size: 0.7rem;
        letter-spacing: 0.2em;
        color: #8a7050;
        text-shadow: 0 0 10px #e8b96060;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <canvas id="c" width="800" height="520"></canvas>
      <div id="hud"><span id="hud-level">LEVEL 1</span></div>
      <div id="overlay">
        <h1>UMBRA</h1>
        <p class="tagline">only light is solid &mdash; darkness is void</p>
        <div class="hint-grid">
          <div class="hint"><span class="key">A / D</span> Move</div>
          <div class="hint"><span class="key">SPACE / W</span> Jump</div>
          <div class="hint"><span class="key">MOUSE</span> Aim lantern</div>
          <div class="hint"><span class="key">SCROLL</span> Widen beam</div>
        </div>
        <p class="tagline" style="margin-top: 6px; font-size: 0.78rem">
          Reach the golden door. Don't step into shadow.
        </p>
        <button class="start-btn" id="startBtn">ENTER THE DARK</button>
      </div>
    </div>
    <script>
      // ── SETUP ──────────────────────────────────────────────────────────────
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      const W = 800,
        H = 520,
        TILE = 40;
      const COLS = 20,
        ROWS = 13; // W/TILE, H/TILE
      const GRAV = 0.55,
        JUMP_VY = -13,
        SPEED = 3.5;

      // ── LEVELS ─────────────────────────────────────────────────────────────
      const LEVELS = [
        {
          hint: "Aim your lantern. Lit tiles hold your weight.",
          map: [
            "####################",
            "#                  #",
            "#                  #",
            "#    .....         #",
            "#                  #",
            "#         .....    #",
            "#                  #",
            "#  .....           #",
            "#                  #",
            "#S                G#",
            "####################",
            "####################",
            "####################",
          ],
        },
        {
          hint: "Scroll to widen your beam and bridge the gaps.",
          map: [
            "####################",
            "#                  #",
            "#                  #",
            "#  ....    ....    #",
            "#                  #",
            "#      ....        #",
            "#                  #",
            "#          ....    #",
            "#                  #",
            "#S         .    G  #",
            "####################",
            "####################",
            "####################",
          ],
        },
        {
          hint: "Light each platform from where you stand, then jump.",
          map: [
            "####################",
            "#                  #",
            "#                  #",
            "#                  #",
            "#  ...             #",
            "#                  #",
            "#       ...        #",
            "#                  #",
            "#           ...    #",
            "#S################G#",
            "####################",
            "####################",
            "####################",
          ],
        },
        {
          hint: "Aim carefully — the path is there if you look for it.",
          map: [
            "####################",
            "#                  #",
            "#                  #",
            "#                  #",
            "#  ..   ...   ..   #",
            "#                  #",
            "#    ...   ...     #",
            "#                  #",
            "#  ..   ...   ..   #",
            "#S################G#",
            "####################",
            "####################",
            "####################",
          ],
        },
      ];

      // ── STATE (all declared before use) ────────────────────────────────────
      const keys = {};
      let gameRunning = false;
      let curLevel = 0;
      let tileMap = []; // tileMap[r][c] = {type,lit,litAmt}
      let player = null; // set by loadLevel()
      let mouse = { x: W / 2, y: H / 2 };
      let lightAngle = 0;
      let lightSpread = 0.45;
      let deathTimer = 0;
      let msgText = "";
      let msgTimer = 0;
      let particles = [];

      // ── LEVEL LOADER ───────────────────────────────────────────────────────
      function loadLevel(idx) {
        const lev = LEVELS[idx];
        tileMap = [];
        let sr = 9,
          sc = 1; // player start fallback

        for (let r = 0; r < ROWS; r++) {
          tileMap[r] = [];
          const row = lev.map[r] || "";
          for (let c = 0; c < COLS; c++) {
            const ch = row[c] !== undefined ? row[c] : " ";
            let type = "air";
            if (ch === "#") type = "wall";
            else if (ch === ".") type = "light";
            else if (ch === "G") type = "goal";
            else if (ch === "S") {
              sr = r;
              sc = c;
            }
            tileMap[r][c] = { type, lit: false, litAmt: 0 };
          }
        }

        // Player feet sit at bottom edge of start tile
        player = {
          x: sc * TILE + TILE / 2,
          y: (sr + 1) * TILE,
          vx: 0,
          vy: 0,
          w: 18,
          h: 28,
          onGround: false,
          dead: false,
          alpha: 1,
        };

        deathTimer = 0;
        document.getElementById("hud-level").textContent = "LEVEL " + (idx + 1);
        showMsg(lev.hint, 3500);
      }

      // ── RAYCASTING ─────────────────────────────────────────────────────────
      function updateLighting() {
        if (!player || tileMap.length === 0) return;

        const ox = player.x;
        const oy = player.y - player.h / 2;
        lightAngle = Math.atan2(mouse.y - oy, mouse.x - ox);

        for (let r = 0; r < ROWS; r++)
          for (let c = 0; c < COLS; c++) {
            tileMap[r][c].lit = false;
            tileMap[r][c].litAmt = 0;
          }

        const RAYS = 220,
          MAX_D = 540,
          STEP = 5;
        for (let i = 0; i < RAYS; i++) {
          const angle =
            lightAngle - lightSpread + (2 * lightSpread * i) / (RAYS - 1);
          const dx = Math.cos(angle),
            dy = Math.sin(angle);
          let x = ox,
            y = oy;
          for (let d = STEP; d < MAX_D; d += STEP) {
            x += dx * STEP;
            y += dy * STEP;
            if (x < 0 || x >= W || y < 0 || y >= H) break;
            const c = Math.floor(x / TILE);
            const r = Math.floor(y / TILE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;
            const tile = tileMap[r][c];
            const b = Math.max(0, 1 - d / MAX_D);
            if (b > tile.litAmt) {
              tile.lit = true;
              tile.litAmt = b;
            }
            if (tile.type === "wall") break;
          }
        }
      }

      // ── PHYSICS ────────────────────────────────────────────────────────────
      function tileAt(wx, wy) {
        const c = Math.floor(wx / TILE);
        const r = Math.floor(wy / TILE);
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
        return tileMap[r][c] || null;
      }

      function isSolid(tile) {
        if (!tile) return false;
        if (tile.type === "wall") return true;
        if (tile.type === "light" && tile.lit) return true;
        return false;
      }

      function resolveX() {
        const hw = player.w / 2;
        const top = player.y - player.h + 2;
        const bot = player.y - 2;
        if (player.vx > 0) {
          const rx = player.x + hw;
          if (isSolid(tileAt(rx, top)) || isSolid(tileAt(rx, bot))) {
            player.x = Math.floor(rx / TILE) * TILE - hw;
            player.vx = 0;
          }
        } else if (player.vx < 0) {
          const lx = player.x - hw;
          if (isSolid(tileAt(lx, top)) || isSolid(tileAt(lx, bot))) {
            player.x = (Math.floor(lx / TILE) + 1) * TILE + hw;
            player.vx = 0;
          }
        }
      }

      function resolveY() {
        const hw = player.w / 2 - 2;
        const lx = player.x - hw,
          rx = player.x + hw;
        if (player.vy > 0) {
          const by = player.y;
          if (isSolid(tileAt(lx, by)) || isSolid(tileAt(rx, by))) {
            player.y = Math.floor(by / TILE) * TILE;
            player.vy = 0;
            player.onGround = true;
          }
        } else if (player.vy < 0) {
          const ty = player.y - player.h;
          if (isSolid(tileAt(lx, ty)) || isSolid(tileAt(rx, ty))) {
            player.y = (Math.floor(ty / TILE) + 1) * TILE + player.h;
            player.vy = 0;
          }
        }
      }

      function updatePlayer() {
        if (!player) return;

        if (player.dead) {
          deathTimer--;
          player.alpha = Math.max(0, deathTimer / 40);
          if (deathTimer <= 0) loadLevel(curLevel);
          return;
        }

        if (keys["KeyA"] || keys["ArrowLeft"]) player.vx = -SPEED;
        else if (keys["KeyD"] || keys["ArrowRight"]) player.vx = SPEED;
        else player.vx *= 0.72;

        player.vy = Math.min(player.vy + GRAV, 18);

        player.x += player.vx;
        resolveX();

        player.onGround = false;
        player.y += player.vy;
        resolveY();

        // Dark-tile death
        if (player.onGround) {
          const hw = player.w / 2 - 3;
          const fy = player.y + 2;
          const tL = tileAt(player.x - hw, fy);
          const tR = tileAt(player.x + hw, fy);
          if (
            (tL && tL.type === "light" && !tL.lit) ||
            (tR && tR.type === "light" && !tR.lit)
          ) {
            triggerDeath();
            return;
          }
        }

        // Out of world
        if (player.y > H + 80 || player.x < -80 || player.x > W + 80) {
          triggerDeath();
          return;
        }

        // Goal — check tile at player centre
        const gt = tileAt(player.x, player.y - player.h / 2);
        if (gt && gt.type === "goal") advanceLevel();
      }

      function triggerDeath() {
        if (player.dead) return;
        player.dead = true;
        deathTimer = 50;
        spawnDeathParticles();
      }

      function advanceLevel() {
        curLevel++;
        if (curLevel >= LEVELS.length) {
          gameRunning = false;
          showOverlay(
            "YOU ESCAPED THE DARK",
            "All shadows conquered.",
            "PLAY AGAIN",
            () => {
              curLevel = 0;
              startGame();
            }
          );
          return;
        }
        spawnLevelParticles();
        loadLevel(curLevel);
      }

      // ── PARTICLES ──────────────────────────────────────────────────────────
      function spawnDeathParticles() {
        for (let i = 0; i < 28; i++) {
          const a = Math.random() * Math.PI * 2,
            s = Math.random() * 4 + 1;
          particles.push({
            x: player.x,
            y: player.y - player.h / 2,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            life: 40 + Math.random() * 30,
            color: `hsl(${30 + Math.random() * 30},80%,${
              50 + Math.random() * 30
            }%)`,
            r: Math.random() * 3 + 1,
          });
        }
      }
      function spawnLevelParticles() {
        for (let i = 0; i < 20; i++) {
          particles.push({
            x: Math.random() * W,
            y: Math.random() * H,
            vx: (Math.random() - 0.5) * 2,
            vy: -Math.random() * 3 - 1,
            life: 60 + Math.random() * 40,
            color: `hsl(45,90%,${60 + Math.random() * 30}%)`,
            r: Math.random() * 3 + 1,
          });
        }
      }
      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.1;
          p.life--;
          if (p.life <= 0) particles.splice(i, 1);
        }
      }

      // ── DRAW ───────────────────────────────────────────────────────────────
      function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, W, H);
        if (!gameRunning) return;

        // Light cone
        if (player) {
          const px = player.x,
            py = player.y - player.h / 2;
          const g = ctx.createRadialGradient(px, py, 0, px, py, 500);
          g.addColorStop(0, "rgba(255,230,160,0.18)");
          g.addColorStop(0.4, "rgba(255,200,100,0.07)");
          g.addColorStop(1, "rgba(0,0,0,0)");
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(px, py);
          ctx.arc(
            px,
            py,
            500,
            lightAngle - lightSpread,
            lightAngle + lightSpread
          );
          ctx.closePath();
          ctx.fillStyle = g;
          ctx.fill();
          ctx.restore();
        }

        // Tiles
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const tile = tileMap[r][c];
            if (!tile) continue;
            const x = c * TILE,
              y = r * TILE;

            if (tile.type === "wall") {
              const b = tile.lit ? tile.litAmt : 0.05;
              ctx.fillStyle = `rgba(40,30,20,${0.3 + b * 0.7})`;
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = `rgba(80,60,40,${b * 0.4})`;
              ctx.lineWidth = 0.5;
              ctx.strokeRect(x + 1, y + 1, TILE - 2, TILE - 2);
            } else if (tile.type === "light") {
              if (tile.lit) {
                const g = ctx.createLinearGradient(x, y, x, y + TILE);
                g.addColorStop(0, `rgba(220,180,100,${0.6 * tile.litAmt})`);
                g.addColorStop(1, `rgba(160,110,50,${0.8 * tile.litAmt})`);
                ctx.fillStyle = g;
                ctx.fillRect(x, y, TILE, TILE);
                ctx.strokeStyle = `rgba(255,220,130,${tile.litAmt * 0.8})`;
                ctx.lineWidth = 1.5;
                ctx.strokeRect(x + 1, y + 1, TILE - 2, TILE - 2);
                ctx.fillStyle = `rgba(255,240,180,${tile.litAmt * 0.12})`;
                ctx.fillRect(x + 4, y + 4, TILE - 8, TILE / 3);
              } else {
                ctx.strokeStyle = "rgba(80,60,40,0.1)";
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 5]);
                ctx.strokeRect(x + 2, y + 2, TILE - 4, TILE - 4);
                ctx.setLineDash([]);
              }
            } else if (tile.type === "goal") {
              const glow = tile.lit ? tile.litAmt : 0.2;
              ctx.fillStyle = `rgba(200,160,40,${glow * 0.7})`;
              ctx.fillRect(x + 6, y + 4, TILE - 12, TILE - 4);
              ctx.strokeStyle = `rgba(255,210,80,${glow})`;
              ctx.lineWidth = 2;
              ctx.strokeRect(x + 6, y + 4, TILE - 12, TILE - 4);
              ctx.beginPath();
              ctx.arc(x + TILE - 12, y + TILE / 2, 3, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(255,220,100,${glow})`;
              ctx.fill();
              if (glow > 0.25) {
                const h = ctx.createRadialGradient(
                  x + TILE / 2,
                  y + TILE / 2,
                  4,
                  x + TILE / 2,
                  y + TILE / 2,
                  34
                );
                h.addColorStop(0, `rgba(255,200,50,${glow * 0.3})`);
                h.addColorStop(1, "rgba(255,200,50,0)");
                ctx.fillStyle = h;
                ctx.fillRect(x - 10, y - 10, TILE + 20, TILE + 20);
              }
            }
          }
        }

        // Particles
        for (const p of particles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.globalAlpha = Math.min(1, p.life / 30);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Player
        if (player) {
          ctx.save();
          ctx.globalAlpha = player.alpha;
          const px = player.x,
            py = player.y,
            hw = player.w / 2,
            hh = player.h;
          const bg = ctx.createLinearGradient(px - hw, py - hh, px + hw, py);
          bg.addColorStop(0, "#d4b878");
          bg.addColorStop(1, "#8a6830");
          ctx.fillStyle = bg;
          ctx.beginPath();
          ctx.roundRect(
            px - hw + 2,
            py - hh + 4,
            player.w - 4,
            player.h - 2,
            3
          );
          ctx.fill();
          ctx.fillStyle = "#2a1e0a";
          ctx.beginPath();
          ctx.moveTo(px - hw, py - hh + 8);
          ctx.lineTo(px - hw - 3, py);
          ctx.lineTo(px + hw + 3, py);
          ctx.lineTo(px + hw, py - hh + 8);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.arc(px, py - hh + 2, 8, 0, Math.PI * 2);
          ctx.fillStyle = "#d4b878";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(px, py - hh + 1, 10, Math.PI, Math.PI * 2);
          ctx.fillStyle = "#1a1208";
          ctx.fill();
          const lx = px + Math.cos(lightAngle) * 12,
            ly = py - hh / 2 + Math.sin(lightAngle) * 12;
          const lg = ctx.createRadialGradient(lx, ly, 0, lx, ly, 18);
          lg.addColorStop(0, "rgba(255,210,80,0.9)");
          lg.addColorStop(1, "rgba(255,140,20,0)");
          ctx.fillStyle = lg;
          ctx.fillRect(lx - 18, ly - 18, 36, 36);
          ctx.beginPath();
          ctx.arc(lx, ly, 4, 0, Math.PI * 2);
          ctx.fillStyle = "#ffe080";
          ctx.fill();
          ctx.restore();
        }

        // Vignette
        const v = ctx.createRadialGradient(
          W / 2,
          H / 2,
          H * 0.2,
          W / 2,
          H / 2,
          H * 0.9
        );
        v.addColorStop(0, "rgba(0,0,0,0)");
        v.addColorStop(1, "rgba(0,0,0,0.65)");
        ctx.fillStyle = v;
        ctx.fillRect(0, 0, W, H);

        // Message
        if (msgTimer > 0) {
          ctx.save();
          ctx.globalAlpha = Math.min(1, msgTimer / 30);
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(0, H - 50, W, 40);
          ctx.font = '14px "Crimson Text",serif';
          ctx.fillStyle = "#c8a860";
          ctx.textAlign = "center";
          ctx.fillText(msgText, W / 2, H - 24);
          ctx.restore();
          msgTimer--;
        }

        // Cursor
        const mx = mouse.x,
          my = mouse.y;
        ctx.strokeStyle = "rgba(255,220,100,0.55)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(mx - 8, my);
        ctx.lineTo(mx + 8, my);
        ctx.moveTo(mx, my - 8);
        ctx.lineTo(mx, my + 8);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(mx, my, 4, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255,200,60,0.45)";
        ctx.stroke();
      }

      // ── OVERLAY HELPER ─────────────────────────────────────────────────────
      function showOverlay(title, sub, btnLabel, cb) {
        const ov = document.getElementById("overlay");
        ov.innerHTML = `
    <h1 style="font-size:clamp(2rem,8vw,4rem);letter-spacing:0.2em">${title}</h1>
    <p class="tagline">${sub}</p>
    <button class="start-btn" id="ovBtn">${btnLabel}</button>
  `;
        ov.style.display = "flex";
        document.getElementById("ovBtn").onclick = () => {
          ov.style.display = "none";
          cb();
        };
      }

      function showMsg(text, ms) {
        msgText = text;
        msgTimer = Math.round(ms / (1000 / 60));
      }

      // ── GAME LOOP ──────────────────────────────────────────────────────────
      function loop() {
        if (gameRunning) {
          updateLighting();
          updatePlayer();
          updateParticles();
        }
        draw();
        requestAnimationFrame(loop);
      }

      // ── INPUT ──────────────────────────────────────────────────────────────
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (!gameRunning || !player || player.dead) return;
        if (e.code === "Space" || e.code === "KeyW" || e.code === "ArrowUp") {
          e.preventDefault();
          if (player.onGround) player.vy = JUMP_VY;
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - r.left) * (W / r.width);
        mouse.y = (e.clientY - r.top) * (H / r.height);
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          lightSpread = Math.max(
            0.08,
            Math.min(1.15, lightSpread + e.deltaY * 0.001)
          );
        },
        { passive: false }
      );

      let touchStartX = 0;
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          touchStartX = e.touches[0].clientX;
          if (gameRunning && player && !player.dead && player.onGround)
            player.vy = JUMP_VY;
        },
        { passive: false }
      );

      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          const r = canvas.getBoundingClientRect();
          mouse.x = (e.touches[0].clientX - r.left) * (W / r.width);
          mouse.y = (e.touches[0].clientY - r.top) * (H / r.height);
          const dx = e.touches[0].clientX - touchStartX;
          keys["KeyA"] = dx < -10;
          keys["KeyD"] = dx > 10;
        },
        { passive: false }
      );

      canvas.addEventListener("touchend", () => {
        keys["KeyA"] = false;
        keys["KeyD"] = false;
      });

      // ── START ──────────────────────────────────────────────────────────────
      function startGame() {
        particles = [];
        curLevel = 0;
        gameRunning = true;
        loadLevel(0);
      }

      document.getElementById("startBtn").onclick = () => {
        document.getElementById("overlay").style.display = "none";
        startGame();
      };

      requestAnimationFrame(loop);
    </script>
  </body>
</html>
